# ---------------- app/main.py ----------------
from fastapi import FastAPI
from app.routes.sharepoint import router as sharepoint_router

app = FastAPI(title="Loan Review Platform API")

# Register Routes
app.include_router(sharepoint_router, prefix="/api/sharepoint", tags=["SharePoint Ingestion"])

# ---------------- app/routes/sharepoint.py ----------------
from fastapi import APIRouter, BackgroundTasks, HTTPException
from app.schemas.sharepoint_request import SharePointIngestionRequest
from app.utils.response_handler import success_response, error_response
from app.services.sharepoint_trigger import trigger_sharepoint_ingestion

router = APIRouter()

@router.post("/trigger")
async def trigger_ingestion(request: SharePointIngestionRequest, background_tasks: BackgroundTasks):
    """
    Trigger SharePoint ingestion and return a unique request_id immediately.
    The actual ingestion process runs in the background.
    """
    try:
        request_id = await trigger_sharepoint_ingestion(request, background_tasks)
        return success_response(message="Ingestion started", data={"request_id": request_id, "status": "pending"})
    except Exception as e:
        return error_response(message="Failed to start ingestion", error=str(e))

# ---------------- app/schemas/sharepoint_request.py ----------------
from pydantic import BaseModel

class SharePointIngestionRequest(BaseModel):
    site_url: str
    sp_folder_path: str
    tenant_id: str
    engagement_id: str

# ---------------- app/services/sharepoint_trigger.py ----------------
import uuid
import yaml
from datetime import datetime
from app.db.mongo_client import MongoDBClient
from app.sharepoint.client import SharePointClient
from app.sharepoint.ingestion_service import SharePointIngestionService


def get_config():
    """Load application configuration."""
    with open("app/config/settings.yaml", "r") as f:
        return yaml.safe_load(f)


async def trigger_sharepoint_ingestion(request, background_tasks):
    """
    Start the SharePoint ingestion in a background thread and return a request ID.
    """
    config = get_config()
    db = MongoDBClient().get_database()
    sharepoint_logs = db["sharepoint_ingestion_logs"]

    request_id = str(uuid.uuid4())
    await sharepoint_logs.insert_one({
        "request_id": request_id,
        "site_url": request.site_url,
        "sp_folder_path": request.sp_folder_path,
        "tenant_id": request.tenant_id,
        "engagement_id": request.engagement_id,
        "status": "pending",
        "timestamp": datetime.utcnow().isoformat(),
        "doc_run_ids": []
    })

    # Start background ingestion
    background_tasks.add_task(
        run_ingestion,
        request.site_url,
        request.sp_folder_path,
        request.tenant_id,
        request.engagement_id,
        request_id,
        config
    )
    return request_id


async def run_ingestion(site_url, sp_folder_path, tenant_id, engagement_id, request_id, config):
    """
    This runs the full ingestion process for SharePoint in background.
    Updates sharepoint_ingestion_logs status and ingests into run_management and run_documents.
    """
    db = MongoDBClient().get_database()
    log_collection = db["sharepoint_ingestion_logs"]

    try:
        sp_client = SharePointClient(site_url, config["client_id"], config["client_secret"])
        folder = sp_client.get_folder(sp_folder_path)

        folder_name = sp_folder_path.strip("/").split("/")[-1]
        year, quarter = sp_client.extract_year_quarter(folder_name)
        if not year or not quarter:
            await log_collection.update_one({"request_id": request_id}, {"$set": {"status": "failed", "error": "Invalid folder name"}})
            return

        ingestion_service = SharePointIngestionService(db, config)
        result = await ingestion_service.ingest(folder, sp_client, tenant_id, engagement_id, year, quarter)

        # Update log
        await log_collection.update_one(
            {"request_id": request_id},
            {"$set": {"status": result["status"], "message": result["message"]}}
        )

    except Exception as e:
        await log_collection.update_one({"request_id": request_id}, {"$set": {"status": "failed", "error": str(e)}})

# ---------------- app/utils/response_handler.py ----------------
def success_response(message: str, data: dict = None):
    return {"status": "success", "message": message, "data": data or {}}

def error_response(message: str, error: str):
    return {"status": "error", "message": message, "error": error}
