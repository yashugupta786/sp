# ---------------- app/config/settings.yaml ----------------
client_id: "your-client-id"
client_secret: "your-client-secret"
mongo_uri: "mongodb://localhost:27017"
database: "test"

# ---------------- app/db/mongo_connection.py ----------------
import yaml
from pymongo import MongoClient

class MongoDBClient:
    """
    Handles MongoDB client creation and database connection
    by reading from a YAML config file.
    """
    def __init__(self, config_path="app/config/settings.yaml"):
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
        self.mongo_uri = config["mongo_uri"]
        self.db_name = config["database"]

    def get_database(self):
        """Returns the database instance from MongoClient."""
        client = MongoClient(self.mongo_uri)
        return client[self.db_name]

# ---------------- app/model/document_schema.py ----------------
from typing import Optional, List
from pydantic import BaseModel

class StatusModel(BaseModel):
    text_extraction: Optional[str] = ""
    vector_indexing: Optional[str] = ""

class SharePointInfoModel(BaseModel):
    relative_path: str
    library_name: str
    site_url: str

class StepModel(BaseModel):
    step_name: str
    result: str
    timestamp: str

class DocumentModel(BaseModel):
    doc_run_id: str
    run_id: str
    tenant_id: str
    engagement_id: str
    year: int
    quarter: str
    industry_type: str
    obligor_name: str
    doc_id: str
    original_filename: str
    renamed_filename: str = ""
    base64: str
    file_hash: str = "hash_placeholder"
    status: StatusModel = StatusModel()
    blob_path: str = ""
    sas_url: str = ""
    sharepoint_info: SharePointInfoModel
    steps: List[StepModel]

# ---------------- app/sharepoint/sharepoint_client.py ----------------
import base64
import io
import re
from office365.sharepoint.client_context import ClientContext
from office365.runtime.auth.client_credential import ClientCredential

class SharePointClient:
    """
    SharePoint client to handle authentication and file operations.
    """
    def __init__(self, site_url: str, client_id: str, client_secret: str):
        credentials = ClientCredential(client_id, client_secret)
        self.ctx = ClientContext(site_url).with_credentials(credentials)
        self.site_url = site_url

    def get_context(self):
        """Returns the initialized SharePoint context."""
        return self.ctx

    def get_folder(self, path: str):
        """Fetches a SharePoint folder by its relative URL."""
        folder = self.ctx.web.get_folder_by_server_relative_url(path)
        self.ctx.load(folder)
        self.ctx.execute_query()
        return folder

    def get_base64_content(self, file_obj):
        """
        Reads file content from SharePoint and returns it as a base64 string.
        """
        try:
            file_url = file_obj.properties["ServerRelativeUrl"]
            file = self.ctx.web.get_file_by_server_relative_url(file_url)
            mem_file = io.BytesIO()
            file.download(mem_file).execute_query()
            mem_file.seek(0)
            return base64.b64encode(mem_file.read()).decode("utf-8")
        except Exception as e:
            print(f"[ERROR] Reading file content: {e}")
            return None

    async def fetch_all_files(self, folder):
        """
        Recursively fetches all files from a given SharePoint folder.
        """
        self.ctx.load(folder.expand(["Folders", "Files"]))
        self.ctx.execute_query()
        all_files = list(folder.files)
        for subfolder in folder.folders:
            all_files.extend(await self.fetch_all_files(subfolder))
        return all_files

    @staticmethod
    def extract_year_quarter(folder_name: str):
        """
        Extracts year and quarter (e.g., Q1_2025 or Q1 2025).
        """
        match = re.match(r"(?i)(Q[1-4])[_\s]?(\d{4})", folder_name.strip())
        if match:
            return match.group(2), match.group(1).upper()
        return None, None

# ---------------- app/sharepoint/ingestion_service.py ----------------
import uuid
from typing import Dict, Any
from app.model.document_schema import DocumentModel, StepModel, SharePointInfoModel

class SharePointIngestionService:
    """
    Responsible for parsing SharePoint folder structures,
    deduplicating files, and updating MongoDB with document metadata.
    """
    def __init__(self, db, config: Dict[str, Any]):
        self.db = db
        self.run_collection = db["run_management"]
        self.doc_collection = db["run_documents"]
        self.site_url = config["site_url"]

    async def ingest(self, folder, sp_client, tenant_id: str, engagement_id: str, quarter: str, year: str):
        """
        Ingests documents from SharePoint into MongoDB based on metadata structure.
        """
        try:
            self._load(folder)
            industries = folder.folders
            if not industries:
                return {"message": "No industry folders found."}

            new_documents = []
            for industry_folder in industries:
                industry = industry_folder.properties["Name"]
                self._load(industry_folder)
                for obligor_folder in industry_folder.folders:
                    obligor = obligor_folder.properties["Name"]
                    self._load(obligor_folder)
                    all_files = await sp_client.fetch_all_files(obligor_folder)

                    for file_obj in all_files:
                        base64_str = sp_client.get_base64_content(file_obj)
                        if not base64_str:
                            continue

                        existing_doc = self.doc_collection.find_one({
                            "tenant_id": tenant_id,
                            "engagement_id": engagement_id,
                            "year": int(year),
                            "quarter": quarter,
                            "industry_type": industry,
                            "obligor_name": obligor,
                            "base64": base64_str
                        })

                        if existing_doc:
                            continue

                        doc_model = DocumentModel(
                            doc_run_id=f"{industry}_{quarter}_{year}_{obligor.replace(' ', '_')}",
                            run_id=self._get_or_create_run_id(tenant_id, engagement_id),
                            tenant_id=tenant_id,
                            engagement_id=engagement_id,
                            year=int(year),
                            quarter=quarter,
                            industry_type=industry,
                            obligor_name=obligor,
                            doc_id=str(uuid.uuid4()),
                            original_filename=file_obj.properties["Name"],
                            renamed_filename="",
                            base64=base64_str,
                            sharepoint_info=SharePointInfoModel(
                                relative_path=file_obj.properties["ServerRelativeUrl"],
                                library_name="Documents",
                                site_url=self.site_url
                            ),
                            steps=[StepModel(
                                step_name="ingestion",
                                result="success",
                                timestamp=str(uuid.uuid1().time)
                            )]
                        )
                        self.doc_collection.insert_one(doc_model.dict())
                        new_documents.append(doc_model.doc_id)

            return {"message": "Ingestion complete.", "documents_added": len(new_documents)}
        except Exception as e:
            return {"error": str(e)}

    def _get_or_create_run_id(self, tenant_id: str, engagement_id: str) -> str:
        """
        Retrieves or creates a new run_id for the given tenant and engagement.
        """
        existing = self.run_collection.find_one({
            "tenant_id": tenant_id,
            "engagement_id": engagement_id
        })
        if existing:
            return existing["run_id"]
        run_id = f"RUN{str(self.run_collection.estimated_document_count() + 1).zfill(3)}"
        self.run_collection.insert_one({
            "run_id": run_id,
            "tenant_id": tenant_id,
            "engagement_id": engagement_id,
            "metadata": []
        })
        return run_id

    def _load(self, folder):
        """
        Loads the folders and files inside a given SharePoint folder.
        """
        folder.context.load(folder.expand(["Folders", "Files"]))
        folder.context.execute_query()

# ---------------- test/test_sharepoint_ingestion.py ----------------
import asyncio
import yaml
from app.db.mongo_connection import MongoDBClient
from app.sharepoint.sharepoint_client import SharePointClient
from app.sharepoint.ingestion_service import SharePointIngestionService

async def test():
    """
    Test script to simulate SharePoint ingestion with user-provided site_url.
    """
    with open("app/config/settings.yaml", "r") as f:
        config = yaml.safe_load(f)

    db = MongoDBClient().get_database()
    site_url = input("Enter SharePoint site URL: ").strip()
    client_id = config["client_id"]
    client_secret = config["client_secret"]

    sp_client = SharePointClient(site_url, client_id, client_secret)
    processor = SharePointIngestionService(db, {"site_url": site_url})

    folder_path = input("Enter SharePoint folder path (e.g., /sites/.../Q1 2025): ").strip()
    tenant_id = input("Enter tenant ID: ").strip()
    engagement_id = input("Enter engagement ID: ").strip()

    folder_name = folder_path.strip("/").split("/")[-1]
    year, quarter = sp_client.extract_year_quarter(folder_name)
    if not year or not quarter:
        print("[ERROR] Could not extract year/quarter")
        return

    folder = sp_client.get_folder(folder_path)
    result = await processor.ingest(folder, sp_client, tenant_id=tenant_id, engagement_id=engagement_id, quarter=quarter, year=year)
    print(result)

if __name__ == "__main__":
    asyncio.run(test())
